<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>JS_notes</title>
		<style type="text/css">
			body{
				font-family: "微软雅黑";
				line-height: 40px;
				margin-left:30px;
			}
			h2{
				color:red;
			}
			span{
				color:red;
				font-weight: bold;
			}	
			
			li{
				font-size: 18px;
				font-weight: normal;	
				margin-bottom:10px;
				margin:5px 50px;
			}
			h3{
				font-size: 18px;
			}
			/*pre{
				font-size:14px;
				background-color: #eee;
				font-family: arial;
				letter-spacing: 2px;
				line-height: 2;
			}
			*/
			/*table通用样式*/
			table{
				margin:0 auto;
				border:1px solid black;
				text-align: center;
				width:700px;
				margin-bottom: 10px;
				border-collapse:collapse
			}
			table,tr,th,td{
				border:1px solid black;
			}
			table caption{
				font-weight: bold;
				font-size: 20px;
				margin-bottom:5px;
			}

			/*class="number"的样式*/
			.number table tr:first-child th:first-child{
				/*background-color: red;*/
				width:300px;
			}
			
			/*class="string"样式*/
			.string table{
				position: relative;
				left:-20px;;
			}
		</style>
	</head>
	<body>
		<ul>
			<h2>Javascript的核心部分</h2>
			<li>ECMAscript是核心语法</li>
			<li>文档对象模型-DOM</li>
			<li>浏览器对象模型-BOM</li>
		</ul>
		<ul>
			<h2>关于ECMAscript</h2>
			<li>ECMAscript不一定要依赖浏览器</li>
			<li>ECMAscript区分大小写</li>
			<li>ECMAscript是松散结构，可保存任何类型的数据</li>
			<li><span>变量名开头必须以字母、下划线和美元符号$开头</span>，其他部分除了这三种外还可以使用数字</li>
			<li>不能用关键字、保留字、true、false、null作为变量名</li>
			<li>六种常量：数字(100)、字符串("")、正则表达式(/gs/ju)、布尔值(true)、对象(null)、数组表达式([1,2,3,4,5]、对象表达式({x:1,y:2}))</li>
			<li>关键字：js中已经被使用的字符</li>
			<li>保留字：js中未来可能会用到的字符</li>
		</ul>
		<ul>
			<h2>关于变量</h2>
			<li>声明变量：制造一个容器</li>
			<li>变量初始化（也叫给变量赋值）：在容器里放入内容</li>
			<li>输出变量的值：打印容器的东西</li>
			<li>定义变量时，只要有定义变量就必须初始化</li>
		</ul>
		<ul>
			<h2>关于数据类型</h2>
			<li>ECMAscript不能创建自定义数据类型</li>
			<li>ECMAscript有三种强制转换数据类型的方法：boolean()，number()和string()</li>
			<li>typeof操作符：用来检测变量或常量的数据类型，除了返回数据类型，还可以返回函数function,返回的值是字符串（注意大小写，字符类型首字母是大写，返回的值首字母是小写）</li>
			<li>Undefined：Undefined只有一个值undefined，它不需要特别去初始化，因为任何变量未初始化的值都是undefined，Undefined类型是为了区别未经初始化的变量类型和空对象类型Null,未经初始化的变量类型和不存在的变量类型是一样的，都是undefined，但他们的值是不一样的，当输出不存在的变量的值浏览器会报错is not defined</li>
			<li>Null：Null只有一个值null，它表示一个空对象，用typeof检测会返回object类型，在变量初始化时，有可能不知道要初始化什么，所以就先给一个null值，遵循“只要定义变量就必须初始化”的原则</li>
		<!--Boolean类型开头-->
			<li>Boolean:Boolean有两个值true和false，任何变量都可以用boolean()（这是一种强制转换类型）转型成布尔值，</li>
			<div class="boolean">
				<table>
					<caption>其他数据类型转换成boolean类型的规则</caption>
					<tr>
						<th>数据类型</th>
						<th>转换为true值</th>
						<th>转换为false值</th>
					</tr>
					<tr>
						<td>Boolean</td>
						<td>true</td>
						<td>false</td>
					</tr>
					<tr>
						<td>String</td>
						<td>非空字符串</td>
						<td>空字符串</td>
					</tr>
					<tr>
						<td>Number</td>
						<td>非零数字值和无穷大</td>
						<td>0和NaN</td>
					</tr>
					<tr>
						<td>Object</td>
						<td>任何对象</td>
						<td>null</td>
					</tr>
					<tr>
						<td>Undefined</td>
						<td>-</td>
						<td>undefined</td>
					</tr>
				</table>
			</div>
		<!--Number类型开头-->
			<li>Number：Number类型包括整型和浮点型，浮点型最高是17位小数，可能导致不精确，用Number.MAX_VALUE和Number.MIN_VALUE可求出浮点型的最小值和最大值，超出范围会出现正无穷infinity或负无穷-infinity，可以用isFinite()判断是否超过范围，true就是没有超过，false就是超过了</li>
				<ul>
					<li>NaN:not a number假如要返回的数值有错误，其他语言本来应该要停止执行，抛出错误，但是js会返回NaN这个值，从而不影响程序执行，例如其他语言任何数字除以0都会抛出错误，停止运行，但是js会抛出NaN，可以用number.NaN得到NaN这个值,任何与NaN进行运算的结果都得到NaN,可以用isNaN()这个函数来判断某个值是不是NaN，NaN不是一个数值</li>
					<li>Number()（这是一种强制转换类型）方法可以把任何类型转换为数值</li>
						<ul>
							<li>Number(true)会得到返回值1,Number(false)会得到返回值0</li>
							<li>Number(25)会直接返回数值25（直接转成10进制），浮点型也会直接返回值，如果是空的就直接返回0，如果不是数字类型就返回NaN</li>
							<li>Number(null)会返回0</li>
							<li>Number(undefined)会返回NaN</li>
						</ul>
					<li>parseInt()可以把数据类型为字符串的内容转换成数字,返回一个整数，<span>方式是parseInt(string)</span></li>
						<ul>
							<li>如果第一位开始不是数值，就返回NaN</li>
							<li>如果第一位开始是数值，就返回整数部分，然后检测第二位，直到不是数值的一位停止输出</li>
							<li>如果数值中出现小数点会被省略</li>
							<li>如果值是空的，则返回NaN</li>
							<li>可以解析十六进制、八进制和二进制，然后返回十进制，例如parseInt('0xA')返回十进制数10</li>
							<li>十六进制和八进制在逗号后注明某进制，可以省略0x，例如parseInt("AF",16)就等于parseInt("0xAF")，parseInt("70",8)就等于parseInt("070")</li>
						</ul>	
					<li>parseFloat()转换数据类型为浮点的数字，<span>方法是parseFloat(string)</span></li>
						<ul>
							<li>可以识别整数,可以识别parseFloat("123")</li>
							<li>不识别16进制数,理论上8进制和2进制也不能识别，返回值为parseFloat("AF",16)</li>
							<li>不管有多少个小数点只认一个小数点，在这个例子中parseFloat("123.4.6")返回值为123.4</li>
							<li>前后有无关的内容会被省略,在这个例子中parseFloat(000123.456000lee)返回值为123.456</li>
							<li>可把科学计数法的数字转换为普通数字,在这个例子中parseFloat("9e+2")返回值为900</li>
						</ul>
					<li>isFinite()和isNaN()判断是否无穷大和判断是否NaN</li>
				</ul>
			<div class="number">
				<table>
					<caption>Number的数字类型和实例</caption>
					<tr>
						<th>数字类型</th>
						<th>实例</th>
					</tr>
					<tr>
						<td>十进制</td>
						<td>250</td>
					</tr>
					<tr>
						<td>八进制（以0开头）</td>
						<td>070</td>
					</tr>
					<tr>
						<td>十六进制（以0x开头，0~9，a~f）</td>
						<td>0xA</td>
					</tr>
					<tr>
						<td>浮点型</td>
						<td>3.8</td>
					</tr>
					<tr>
						<td>科学计数法</td>
						<td>4.12e3</td>
					</tr>
				</table>
			</div>
	<!--String开头-->			
			<li>String：由0或多个16位Unicode字符串组成的字序列，字符串用单引号或双引号表示</li>
				<ul>
					<li>string包含了特殊字符的常量，也叫转义序列</li>
						<div class="string">
						<table>
							<caption>String的一些特殊常量</caption>
							<tr>
								<th>常量名</th>
								<th>含义</th>
							</tr>
							<tr>
								<td>/n</td>
								<td>换行</td>
							</tr>
							<tr>
								<td>/t</td>
								<td>插入一个tab键的距离</td>
							</tr>
							<tr>
								<td>/b</td>
								<td>插入一个空格的距离</td>
							</tr>
							<tr>
								<td>/r</td>
								<td>插入一个回车</td>
							</tr>
							<tr>
								<td>//</td>
								<td>插入一个斜杠</td>
							</tr>
							<tr>
								<td>/'和/"</td>
								<td>插入一个引号</td>
							</tr>
						</table>
						</div>	
					<li>toString()可以把布尔值、数字转换成字符串，<span>方法是number.toString(radix)</span>，toString()在转换时可以改变进制后输出成字符串,例如var box=10 alert(box.toString(2))</li>
					<li>toString()不可以转换null和undefined，但String()（这是一种强制转换类型）可以将任何类型的值转换为字符串，方法是<span>String(object)</span></li>
				</ul>
				
			<li>Object:用{}或new Object创建空的对象（空的对象不等于空对象，空对象是null）可以使用new操作符来创建任何类型的对象</li>
				<ul>
					<li>Object()可以输出数值，字符串，布尔值</li>
					<li>new Number(60)是输出一个数值对象（仍然是对象）</li>
				</ul>
		</ul>
	<ul>
		<h2>关于运算符</h2>
		<li>一元运算符</li>
			<ul>
				<h3>++和++在计算变量本体时就是累加作用，但在变量与变量的赋值中有点不同</h3>
				<!--具体参照一下script.js 从59-68行，先赋值还是后赋值的问题-->
				<li>++box，等于box本身先+1(先自增再赋值）)，然后再赋值给其他变量</li>
				<li>--box，等于box本身先-1，然后再赋值给其他变量</li>
				<li><span>box++，先把box赋值给变量（先赋值再自增），然后box本身+1</span></li>
				<li>box--，先把box赋值给变量，然后box本身-1</li>
				<h3>++和--在对象中使用时，要运用valueOf和toString方法</h3>
				<!--具体参照script.js 从78-84行-->
				<li>++和--在变量和常量上使用时，如果遇到非数字，则会返回NaN</li>
				<li>在对象中使用时，要使用valueOf和toString方法</li>
				<h3>+和-运算符</h3>
				<li>+box和-box是取正取负</li>
			</ul>
		<li>算术运算符</li>
		<ul>
			<li>数值+/-/*/÷数值=数值</li>
			<li>数值+/-/*/÷NaN=NaN</li>
			<li>数字+字符串等于字符串，等号变为字符串连接符</li>
			<!--具体参照script.js 从95-98行-->
			<li>计算的优先级从左往右，和数学优先级类似</li>
			<!--具体参照script.js 从99-100行-->	
			<li>在对象中使用时，要使用valueOf和toString方法</li>
			<!--具体参照script.js 从103-108行-->
			<li>和true计算会转换成1，和false计算会转换成0，和空的字符串计算会转换成0，和null计算会转换成0</li>
			<li>减法、乘法、除法会把字符串内的数字自动转化为Number类型，若字符串内不是数字则返回NaN</li>
		</ul>
		<li>用于进行比较的关系运算符</li>
			<ul>
				<h3>关系运算符大多返回的是布尔值</h3>
				<li>两个都是数值，则进行数值比较</li>
				<li>有一个是字符串，则会将字符串转换成数值再比较</li>
				<li>两个都是数字字符串，则会比较第一个字符的大小</li>
				<li>两个数值中有一个是对象，则先把对象中valueOf()和toString()返回的值计算出来，再进行比较</li>
				<li>布尔值会转换成数值再进行比较</li>
				<li>两个都是不为数值的字符串，则比较二者的ASCII码</li>
				<li>只要和NaN相关的都不相等</li>
				<li>两个对象相比的是地址，每个对象的地址都不相同，因此不同对象都不会相等</li>
				<li>字符串在比较时会自动转换，但null和undefined不会自动转换</li>
				<!--具体参照script.js 从118-128行-->
			</ul>
		<li>逻辑运算符AND、OR和NOT</li>
			<ul>
				<li>AND使用&&，必须两边都是true，才能返回true，只要有一边是false，则返回false</li>
					<ul>
						<li>若第一个操作数是对象，则直接返回第二个操作数</li>
						<!--具体参照script.js 从139-143行-->
						<li>第一个操作数必须返回true，才返回第二个操作数的判断结果，否则不计算第二个操作数的值，且返回false</li>
						<!--具体参照script.js 从148-152行-->
						<li>有一个操作数是null，则返回null</li>
						<li>有一个操作数是undefined，则返回undefined</li>
					</ul>
				<li>OR使用||，只要一边是true就返回true</li>
					<ul>
						<li>第一个操作数是对象，则返回第一个操作数</li>
						<!--具体参照script.js 从155行-->
						<li>两个操作数都是对象，则返回第一个操作数</li>
						<!--具体参照script.js 从164行-->
						<li>第一个操作数是true，不返回第二个操作数，第一个操作数结果为false才返回第二个操作数</li>
						<!--具体参照script.js 从157行-->
						<li>两个都是null,undefined,NaN则返回相同的值</li>
						<li>把其中一个有效变量赋给box</li>
						<!--具体参照script.js 从179行-->
					</ul>
				</li>
				<li>NOT使用！，无论任何数据类型都会返回一个布尔值，NOT的本质是先把这个值转换成布尔值，然后再取反</li>
				<ul>
					<li>对象取反直接返回false</li>
					<!--具体参照script.js 从183行-->
					<li>空的字符串等于0，0等于false，再取反等于true</li>
					<li>字符串取反直接返回false</li>
					<li>null,undefined,NaN取反都是true</li>
				</ul>
			</ul>
		<li>位运算符，针对操作数的二进制计算</li>
		<ul>
		<!--位运算原理参考http://www.w3school.com.cn/js/pro_js_operators_bitwise.asp-->
		<li>位运算NOT，符号为~，位运算NOT实际上是对数字求负，然后减1（原理上负数是要对数字的二进制进行反码处理，但JS，为了避免开发者访问位31，未使用二进制补码，而是使用了数字绝对值前面加负号）</li>
		<!--具体参照script.js 从185-186行-->
		<li>位运算AND，符号为&，位运算AND是把两个数字的二进制进行上下比较</li>
		<!--具体参照script.js 从189-190行-->
		<li>位运算OR，符号为|，位运算OR是把两个数字的二进制进行上下比较</li>
		<!--具体参照script.js 从198-199行-->
		<li>位运算XOR，符号为^，位运算XOR是把两个数字的二进制进行上下比较</li>
		<!--具体参照script.js 从209-210行-->
		<li>左移运算，符号为<<，它把数字中的所有数位向左移动指定的数量</li>
		<!--具体参照script.js 从219-220行-->
		<li>有符号右移运算符号位>>，W3C资料不明</li>
		</ul>
		<li>赋值运算符</li>
		<ul>
			<li>= 把右边的值赋给左边的变量</li>
			<li>x+=y 等于x=x+y</li>
			<li>x-=y 等于x=x-y</li>
			<li>x*=y 等于x=x*y</li>
			<li>x/=y 等于x=x/y</li>
			<li>x%=y 等于x=x%y</li>
			<!--具体参照script.js 从225-231行-->
			<li>字符串运算符 + 只要有字符串的，就以字符串相连</li>
		</ul>
		<li>逗号运算符</li>
			<ul>
				<li>多个变量进行声明</li>
				<!--具体参照script.js 从234-235行-->
				<li>数组声明</li>
				<!--具体参照script.js 从237-238行-->
				<li>对象声明</li>
				<!--具体参照script.js 从245-250行-->
			</ul>
		<li>三元运算符</li>
			<ul>
				<li>if...else使用..?..:</li>
				<!--具体参照script.js 从253-264行-->
			</ul>
	</ul>
	<ul>
		<h2>流程运算符</h2>
		<li>语句的定义</li>
		<div class="sentence">
			<table>
				<tr>
					<th>类型</th>
					<th>子类型</th>
					<th>语法</th>
				</tr>
				<tr>
					<td rowspan="2">声明语句</td>
					<td>变量声明语句</td>
					<td>var box=100</td>
				</tr>
				<tr>
					<td>标签声明语句</td>
					<td>label:box</td>
				</tr>
				<tr>
					<td rowspan="4">表达式语句</td>
					<td>变量赋值语句</td>
					<td>box=3</td>
				</tr>
				<tr>
					<td>函数调用语句</td>
					<td>box()</td>
				</tr>
				<tr>
					<td>属性赋值语句</td>
					<td>box.property=100</td>
				</tr>
				<tr>
					<td>方法调用语句</td>
					<td>box.method()</td>
				</tr>
				<tr>
					<td rowspan="2">分支语句</td>
					<td>条件分支语句</td>
					<td>if(...){...}else{...}</td>
				</tr>
				<tr>
					<td>多重分支语句</td>
					<td>switch(..){case:n..}</td>
				</tr>
				<tr>
					<td rowspan="4">循环语句</td>
					<td>for</td>
					<td>for(;;;){...}</td>
				</tr>
				<tr>
					<td>for in</td>
					<td>for(x in x){...}</td>
				</tr>
				<tr>
					<td>while</td>
					<td>while(...){...}</td>
				</tr>
				<tr>
					<td>do while</td>
					<td>do{...}while(...)</td>
				</tr>
				<tr>
					<td rowspan="5">控制结构</td>
					<td>继续执行子句</td>
					<td>continue;</td>
				</tr>
				<tr>
					<td>终端执行子句</td>
					<td>break;</td>
				</tr>
				<tr>
					<td>函数返回子句</td>
					<td>return;</td>
				</tr>
				<tr>
					<td>异常触发子句</td>
					<td>throw;</td>
				</tr>
				<tr>
					<td>异常捕获与处理</td>
					<td>try{..}catch(..){..}finally{..}</td>
				</tr>
				<tr>
					<td rowspan="2">其他</td>
					<td>空语句</td>
					<td>;</td>
				</tr>
				<tr>
					<td>with语句</td>
					<td>with(..){..}</td>
				</tr>
			</table>
		</div>
		<li>if语句,一般用于比较大于小于</li>
			<ul>
				<li>只有if，没有else</li>
				<!--Line:273-->
				<li>if...else</li>
				<!--Line:298-303-->
				<li>多重分支if...else if...else if...else</li>
				<!--Line:305-314-->
			</ul>
		<li>switch语句，switch基于不同的条件来执行不同的动作,表达式的值会与结构中的每个 case 的值做比较。如果存在匹配，则与该 case 关联的代码块会被执行</li>
			<ul>
				<li>语法：switch(变量名){<br />
					case 1:执行动作;<br />
					case 2:执行动作;<br />
					case n:执行动作;<br />
					default:执行动作} </li>
				<li>default:来规定匹配不存在时做的事情</li>
				<!--Line:316-324-->
			</ul>
		<li>do..while语句，先执行一次代码，然后再检查条件是否为真，如果为真则重复这个循环</li>
			<ul>
				<li>语法：do{执行语句}while(条件)</li>
			</ul>
		<!--Line328-332-->
		<li>while语句，先判断，再执行循环体</li>
			<ul>
				<li>while(条件){执行语句}</li>
			</ul>
		<!--Line337-341-->
		<li>for语句只要判断条件为true就会一直执行,直到判断条件为false</li>
			<ul>
				<li>for(声明变量和初始化；定义循环的条件，判断为true的执行规则){执行行为}</li>
				<li>for(这里的三个参数可以省略，但不能省略；号)</li>
			</ul>
		<!--Line346-348-->
		<li>for in for/in 语句用于循环对象属性。循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作</li>
			<ul>
				<li>for in语句：for(变量 in 对象){执行语句}</li>
			</ul>
		<!--Line352-359-->
		<li>break;立即退出循环，执行循环后的语句，break只能用在循环和switch中</li>
		<!--Line:365-370-->
		<li>continue;跳过当前条件，继续执行</li>
		<!--Line:373-378-->
	</ul>
	<ul>
		<h2>函数</h2>
		<li>函数的基本格式function 函数名(参数){函数体}，声明函数的方法请看注释</li>
		<!--Line:391-396-->
		<li>return返回值</li>
		<!--Line:418-422-->
		<li>arguments对象</li>
		<!--Line:425-435-->
		<!--关于自动获取arguments数量的方法 Line:438-446-->
		<li>JS的函数不会重载，即不会选择相同参数数量的函数，新的函数会覆盖掉旧的汉服</li>
	</ul>
	<ul>
		<h2>对象和数组</h2>
		<li>对象是一种引用类型，是一种类，引用类型和值的不同</li>
		<!--Line566-575-->
		<li>Object类型</li>
			<ul>
				<li>创建对象{}、创建属性，不同的表达方法(实际开发更喜欢用字面量的方法)</li>
				<!--Line:433-455-->
				<li>对象封装数据</li>
				<!--Line:442-448-->
				<li>把函数赋值给对象属性</li>
				<!--Line:467-483-->
				<li>删除对象</li>
				<!--Line:455-->
				<li>匿名对象，只是用来传参</li>
			</ul>
		<li>数组也是一种引用类型</li>
		<li>Array类型</li>
			<ul>
				<li>创建数组[]，给数组分配元素</li>
				<!--Line:491-->
				<li>length获取数组的元素量</li>
				<!--Line:516-->
				<li>创建复杂的数组</li>
			</ul>
		<li>对象和数组中的方法</li>
			<ul>
				<li>对象和数组都拥有toString()，valueOf()和toLocaleString()方法</li>
				<!--Line:540-543-->
				<li>join()方法更改连接符</li>
				<!--Line:545-->
				<li>栈的后进先出方法，在数组末尾增加元素push(),并输出数组长度,pop()在数组末端移除元素，并返回移除的元素值</li>
				<li>队列的先进先出方法，在数组前端增加元素unshift()，并输出数组长度，shift()在数组前端移除元素，并返回移除的元素值</li>
				<!--Line:547-558-->
				<li>数组的排序方法从小到大排序sort()和逆向排序reserve()</li>
				<!--Line:565-577-->
				<li>基于原来的数组，再创建一个新的数组concat()</li>
				<!--Line:590-594-->
				<li>基于原来数组的指定区域，再创建一个新的数组slice()</li>
				<!--Line:596-->
				<li>基于原来的数组，在数组内删除或替换元素元素splice()</li>
				<!--Line:606-609-->
			</ul>
		<li>时间和日期</li>
			<ul>
				<li>创建Date类型，使用Date.parse()和Date.UTC()</li>
				<!--Line:614-637-->
				<li>用toString()，valueOf()和toLocaleString()三个通用方法</li>
			</ul>
	</ul>
	<ul>
		<h2>正则表达式</h2>
		<li>ECMAscript中的RegExp表示正则表达式</li>
		<li>创建正则表达式</li>
			<table>
				<caption>模式修饰符的可选参数</caption>
				<tr>
					<th>参数</th>
					<th>含义</th>
				</tr>
				<tr>
					<td>i</td>
					<td>忽略大小写</td>
				</tr>
				<tr>
					<td>g</td>
					<td>全局匹配</td>
					<!--(普通的匹配方式是只匹配到1个就停止，全局匹配是指在全文匹配到无法匹配为止)-->
				</tr>
				<tr>
					<td>m</td>
					<td>多行匹配</td>
				</tr>
			</table>
		<li>如何测试正则表达式test()和exec()</li>
		<!--Line:713-719-->
			<table>
				<caption>正则表达式的两个测试方法</caption>
				<tr>
					<th>方法</th>
					<th>作用</th>
				</tr>
				<tr>
					<td>test()</td>
					<td>查找是否有匹配的内容，返回true或false</td>
				</tr>
				<tr>
					<td>exec()</td>
					<td>查找是否有匹配的内容，有则以数组的形式返回字符串,没有返回null</td>
				</tr>
			</table>
		<li>字符串的四个方法match(),replace(),search(),split()</li>
		<!--Line:722-743-->
			<table>
				<caption>正则在字符串中的四个方法</caption>
				<tr>
					<th>方法</th>
					<th>作用</th>
				</tr>
				<tr>
					<td>match()</td>
					<td>将所有匹配的字符串组合成数组返回</td>
				</tr>
				<tr>
					<td>search()</td>
					<td>查找并返回字符串的位置，否则返回-1</td>
				</tr>
				<tr>
					<td>replace()</td>
					<td>替换掉字符串的内容</td>
				</tr>
				<tr>
					<td>split()</td>
					<td>把一个字符串拆分为数组</td>
				</tr>
			</table>
		<li>正则的静态属性RegExp.input，RegExp.leftContext，RegExp.rightContext，RegExp.lastMatch，RegExp.astParen</li>
			<table>
				<caption>正则的静态属性对应短名</caption>
				<tr>
					<th>属性</th>
					<th>含义</th>
					<th>短名</th>
				</tr>
				<tr>
					<td>RegExp.input</td>
					<td>输出当前被匹配的字符串</td>
					<td>RegExp['$_']或RegExp.$_</td>
				</tr>
				<tr>
					<td>RegExp.lastMatch</td>
					<td>输出最后一个匹配的字符串</td>
					<td>RegExp['$&']</td>
				</tr>
				<tr>
					<td>RegExp.lastParen</td>
					<td>输出最后一对圆括号内匹配字符串</td>
					<td>RegExp['$+']</td>
				</tr>
				<tr>
					<td>RegExp.leftContext</td>
					<td>输出输出匹配到字符前的所有子串</td>
					<td>RegExp['$`']</td>
				</tr>
				<tr>
					<td>RegExp.rightContext</td>
					<td>输出匹配到字符后的所有子串</td>
					<td>RegExp['$'']</td>
				</tr>
			</table>
	<li>正则的实例属性.global，.ignoreCase，.multiline，.source，.lastIndex</li>
		<table>
			<caption>正则的实例属性</caption>
			<tr>
				<th>属性</th>
				<th>作用</th>
			</tr>
			<tr>
				<td>.global</td>
				<td>是否使用了全局</td>
			</tr>
			<tr>
				<td>.ignoreCase</td>
				<td>是否区分了大小写</td>
			</tr>
			<tr>
				<td>.multiline</td>
				<td>是否设置了多行匹配</td>
			</tr>
			<tr>
				<td>.source</td>
				<td>输出正则里面的源字符串</td>
			</tr>
			<tr>
				<td>.lastIndex</td>
				<td>表示下次匹配从哪个位置开始</td>
			</tr>
		</table>
	<li>正则表达式获取控制</li>
		<table class='yuanzifu'>
			<caption>元字符</caption>
			<tr>
				<th>字符名</th>
				<th>作用</th>
			</tr>
			<tr>
				<td>.</td>
				<td>查找任意单个字符，除了换行和行结束符</td>
			</tr>
			<tr>
				<td>^</td>
				<td>匹配不在范围内的字符</td>
			</tr>
			<tr>
				<td>/w</td>
				<td>匹配字母、数字及下划线</td>
			</tr>
			<tr>
				<td>/W</td>
				<td>匹配非字母、数字及下划线</td>
			</tr>
			<tr>
				<td>/d</td>
				<td>匹配数字</td>
			</tr>
			<tr>
				<td>/D</td>
				<td>匹配非数字</td>
			</tr>
			<tr>
				<td>/s</td>
				<td>匹配空白字符</td>
			</tr>
			<tr>
				<td>/S</td>
				<td>匹配非空白字符</td>
			</tr>
			<tr>
				<td>/b</td>
				<td>匹配边界</td>
			</tr>
		</table>
		<table class='chongfuzifu'>
			<caption>重复字符</caption>
			<tr>
				<th>字符名</th>
				<th>作用</th>
			</tr>
			<tr>
				<td>*</td>
				<td>查找0个，1个或者多个x的字符串，等于{0,}</td>
			</tr>
			<tr>
				<td>+</td>
				<td>查找至少一个x的字符串，等同于{1,}</td>
			</tr>
			<tr>
				<td>?</td>
				<td>查找0个或1个字符串，等同于{0,1}</td>
			</tr>
			<tr>
				<td>x{1,2}</td>
				<td>查找最少1个，最多2个x字符串</td>
			</tr>
			<tr>
				<td>^x</td>
				<td>从行首开始匹配</td>
			</tr>
			<tr>
				<td>x$</td>
				<td>从行尾开始匹配</td>
			</tr>
		</table>
		</table>
		<table class='zifulei'>
			<caption>字符类匹配</caption>
			<tr>
				<th>字符名</th>
				<th>作用</th>
			</tr>
			<tr>
				<td>[a-z]</td>
				<td>26个小写字母都匹配,如果正则加上i就覆盖了大写字母</td>
			</tr>
			<tr>
				<td>[A-Z]</td>
				<td>26个大写字母都匹配,如果正则加上i就覆盖了小写字母</td>
			</tr>
			<tr>
				<td>[0-9]</td>
				<td>0-9的数字都匹配</td>
			</tr>
			<tr>
				<td>[a-zA-Z0-9_]</td>
				<td>复合匹配（等于\w）</td>
			</tr>
			<tr>
				<td>(google|baidu|soso)</td>
				<td>匹配三种之一字符串</td>
			</tr>
			<tr>
				<td>(google){4,8}</td>
				<td>匹配整个字符串4-8次</td>
			</tr>
		</table>
		<li>正则表达式分组</li>
			<ul>
				<li>alert(RegExp.$1)获取表达式中第一个分组中的字符串</li>
				<li>$1$2的用法</li>
			</ul>
		<li>贪婪和惰性</li>
			<ul>
				<li>a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配</li>
				<li>a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）</li>
			</ul>
		<!--http://www.runoob.com/w3cnote/regular-expression-30-minutes-tutorial.html-->
			 <table>
			 	<caption>贪婪的惰性符号</caption>
			 	<tr>
			 		<td>贪婪</td>
			 		<td>惰性</td>
			 	</tr>
			 	<tr>
			 		<td>+</td>
			 		<td>+?</td>
			 	</tr>
			 	<tr>
			 		<td>*</td>
			 		<td>*?</td>
			 	</tr>
			 	<tr>
			 		<td>{n,m}</td>
			 		<td>{n,m}?</td>
			 	</tr>
			 	<tr>
			 		<td>{n,}</td>
			 		<td>{n,}?</td>
			 	</tr>
			 </table>
		<li>用分组捕获（具体看js）</li>
		<li>常用正则</li>
			<ul>
				<li>先把标准的字符串写出来，然后再根据字符串写正则</li>
				<table>
					<caption>常用正则表达式</caption>
					<tr>
						<th>作用</th>
						<th>写法</th>
					</tr>
					<tr>
						<td>验证邮政编码</td>
						<td>/[0-9][1-9]{5}/</td>
					</tr>
					<tr>
						<td>验证文件名</td>
						<td>/\w+\.zip|rar\7z/</td>
					</tr>
					<tr>
						<td>删除多余空格</td>
						<td>/\s/g</td>
					</tr>
					<tr>
						<td>删除前后空格</td>
						<td>/^\s+(.*)\s+$/</td>
					</tr>
					<tr>
						<td>验证电子邮件</td>
						<td>/^([\w\.\-]+)@([\w\-]+cn|com/</td>
					</tr>
				</table>
			</ul>
			<h2>function类型</h2>
			<li>111</li>
	</ul>
		<!--<p>ECMAscript-语法部分</p>
		<p>文档对象模型-DOM</p>
		<p>浏览器对象模型-BOM</p>
		-->
	</body>
</html>
